1.-
    a) Compila y ejecuta el programa DeviceInfo.c. Comprueba la información 
    que te muestra. No te preocupes si no entiendes todav´ıa alguno de los 
    datos mostrados.

        Adjunto info.txtx

    b) Revisa el código y averigua qué funciones se utilizan para obtener 
    la lista de plataformas y la lista de dispositivos de cada una de ellas. 
    Consulta en la guía de referencia o en la página 
    https://www.khronos.org/opencl/ el significado de los argumentos de ambas 
    funciones ¿Por qué se llama dos veces a ambas funciones?

        Obtener el numero de plataformas:
        clGetPlatformIDs(num_platforms, platform, NULL);

        Obtener el nombre de cada plataforma:
        clGetPlatformInfo(platform[i], CL_PLATFORM_NAME, sizeof(string), &string, NULL);
        
        Obtener el numero de dispositivos:
        clGetDeviceIDs(platform[i], CL_DEVICE_TYPE_ALL, 0, NULL, &num_devices) 

        Obtener los IDs de dispositivos:
        clGetDeviceIDs(platform[i], CL_DEVICE_TYPE_ALL, num_devices, device, NULL);

    c) ¿Qué funciones se utilizan para obtener información de las 
    plataformas? ¿y de los dispositivos? Averigua el significado de los 
    argumentos de ambas funciones

        clGetPlatformInfo y clGetDeviceInfo

        Parámetros en:
        https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html ,
        https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetPlatformInfo.html

    d) Modifica el programa para que por cada dispositivo se muestre también 
    su máxima frecuencia de reloj.

        // Get device frequency
        cl_uint freq;
        err = clGetDeviceInfo(device[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(cl_uint), &freq, NULL);
        checkError(err, "Getting device name");
        printf("\t\tFreq: %d\n", string);




-------------------------------------------------------------------------------------

2.- 
    a) Revisa el código del programa vadd.c y localiza las principales 
    etapas del mismo y las llamadas a la API que se realizan en cada una 
    de ellas.

        Las llamadas están indicadas sobre el código con comentarios.    

    b) ¿Cómo elegimos el tipo de dispositivo sobre el que vamos a 
    ejecutar el código?

        #define DEVICE_TYPE CL_DEVICE_TYPE_ALL

        err = clGetDeviceIDs(platform, DEVICE_TYPE, 1, &device, NULL);
        checkError(err, "Finding a device");
    
    c) ¿Cómo procesamos los posibles errores de las llamadas a la API?

        con el método checkError

    d) ¿Cómo medimos el tiempo empleado por el kernel y nos aseguramos 
    de que este haya acabado?

        Con una función auxiliar llamada wtime() y esperando a que acabe 
        con la llamada clFinish(commands) a la API

    e) ¿Dónde está el código del kernel a ejecutar y cómo construimos 
    el programa a partir de él?

        En el archivo vadd.cl. Se construye el programa mediante las llamadas:

        char * filename="vadd.cl";

        char *kernelSource = getKernelSource(filename);
        program = clCreateProgramWithSource(context, 1, (const char **) &kernelSource, NULL, &err);

        De esta manera se pasa al programa el código del kernel como una cadena.


-------------------------------------------------------------------------------------

3.-
    a) Modifica el código del kernel para que cada work-item sume uno de los 
    elementos de los tres vectores.

        Adjunto vadd_abc.cl



    b) Modifica el código del host para que el programa gestione la suma de tres 
    vectores generados aleatoriamente usando la nueva versión del kernel.

        Adjunto vadd_abc.c


-------------------------------------------------------------------------------------

4.-
    a) Revisa el código del programa matmul.c y averigua qué hacen las funciones 
    auxiliares parseArguments, getDeviceList y getDeviceName

        parseArguments asigna a deviceIndex el valor de un argumento pasado 
        al llamar al programa (--device X)

        getDeviceList devuelve el numero de dispositivos

        getDeviceName devuelve el nombre del dispositivo 

    b) Revisa el código de creación de los buffers. ¿Cómo se transfieren las 
    matrices de entrada al dispositivo? Modifica el código para que las matrices 
    A y B se transfieran de otra forma



    c) Prueba el código y observa el resultado obtenido para distintos tamaños de 
    matrices. ¿Cómo evolucionan las prestaciones con el tamaño de las matrices?




    d) ¿Qué tamaño global de dominio se utiliza para lanzar el kernel? ¿Qué 
    tamaño  de workgroup? Modifica el código para que se use un tamaño de 
    work-group introducido en la línea de órdenes



    e) Comprueba el efecto sobre las prestaciones de mantener un tamaño de 
    matriz e ir variando el tamaño de work-group. ¿Obtienes en algún caso mejores 
    prestaciones que cuando no especificabas el tamaño del work-group?

    global: 128,256,512,1024,2048
    local: 4x4

    global: 1024
    local: 1x, 2x, 4x, 8x



    f) ¿Puedes usar cualquier tamaño de work-group? ¿Por qué?



-------------------------------------------------------------------------------------

5.-
    a) Escribe el kernel row.cl en el que cada work-item calcula una fila de la 
    matriz resultado C. Las matrices se guardarán en memoria global.



    b) Modificar el código del programa matmul.c para que, después de realizar las 
    dos primeras versiones del producto utilice el nuevo kernel para calcular el 
    producto.



    c) Compara las prestaciones de las tres versiones modificando el tamaño de las 
    matrices y del work-group.




